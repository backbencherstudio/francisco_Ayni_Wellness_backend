generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextSearchPostgres"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Account {
  id         String   @id @default(cuid())
  created_at DateTime @default(now())
  updated_at DateTime @default(now())

  user_id String
  user    User   @relation(fields: [user_id], references: [id], onDelete: Cascade)

  type                String?
  provider            String?
  provider_account_id String?
  refresh_token       String?
  access_token        String?
  expires_at          DateTime?
  token_type          String?
  scope               String?
  id_token            String?
  session_state       String?

  @@unique([provider, provider_account_id])
  @@map("accounts")
}

model User {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  approved_at  DateTime?
  availability String?

  apple_id   String? @unique
  google_id  String? @unique

  email      String? @unique
  username   String? @unique
  name       String? @db.VarChar(255)
  first_name String? @db.VarChar(255)
  last_name  String? @db.VarChar(255)
  password   String? @db.VarChar(255)
  domain     String? @unique
  avatar     String?

  phone_number  String?
  country       String?
  state         String?
  city          String?
  address       String?
  zip_code      String?
  gender        String?
  date_of_birth DateTime? @db.Date

  // billing id. e.g. stripe customer id
  billing_id String?

  IsSubscriptionActive Boolean? @default(false)

  type              String?   @default("user")
  email_verified_at DateTime?

  user_type UserType? @default(Normal)

  is_two_factor_enabled Int?    @default(0)
  two_factor_secret     String? // secret key for two factor authentication

  agree_to_terms Boolean? @default(false)

  accounts                  Account[]
  creator_conversations     Conversation[] @relation("creator")
  participant_conversations Conversation[] @relation("participant")
  receiver_messages         Message[]      @relation("receiver")
  sender_messages           Message[]      @relation("sender")
  receiver_notifications    Notification[] @relation("receiver")
  sender_notifications      Notification[] @relation("sender")

  user_payment_methods UserPaymentMethod[]
  user_settings        UserSetting[]
  ucodes               Ucode[]
  roles                Role[]
  role_users           RoleUser[]
  payment_transactions PaymentTransaction[]
  subscriptions        Subscription[]
  Habit                Habit[]
  Mood                 Mood[]
  statistics           Statistics[]
  Reminders            Reminders[]
  Inspiration          Inspiration[]
  mood_entries         MoodEntry[]
  mood_daily_aggregates MoodDailyAggregate[]
  habit_logs            HabitLog[]
  support_tickets       SupportTicket[]
  // AI Routines relations
  routine_profile       UserRoutineProfile?
  routines              Routine[]
  routine_mood_checks   RoutineMoodCheck[]

  @@map("users")
}

enum UserType {
  Premium
  Trial
  Normal
}

model Ucode {
  id         String   @id @default(cuid())
  created_at DateTime @default(now())
  updated_at DateTime @default(now())

  user_id String?
  user    User?   @relation(fields: [user_id], references: [id])

  token      String?
  email      String?
  expired_at DateTime?

  @@map("ucodes")
}

model Role {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())

  status Int?    @default(1) @db.SmallInt
  title  String?
  name   String?

  user_id String?
  user    User?   @relation(fields: [user_id], references: [id], onDelete: Cascade)

  permission_roles PermissionRole[]
  role_users       RoleUser[]
  permissions      Permission[]     @relation("PermissionToRole")

  @@map("roles")
}

model Permission {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  status     Int?    @default(1) @db.SmallInt
  title      String?
  action     String?
  subject    String?
  conditions String?
  fields     String?

  permission_roles PermissionRole[]
  roles            Role[]           @relation("PermissionToRole")

  @@map("permissions")
}

model PermissionRole {
  created_at DateTime @default(now())
  updated_at DateTime @default(now())

  permission_id String
  permission    Permission @relation(fields: [permission_id], references: [id], onDelete: Cascade)

  role_id String
  role    Role   @relation(fields: [role_id], references: [id], onDelete: Cascade)

  @@id([permission_id, role_id])
  @@map("permission_roles")
}

model RoleUser {
  created_at DateTime @default(now())
  updated_at DateTime @default(now())

  role_id String
  role    Role   @relation(fields: [role_id], references: [id], onDelete: Cascade)

  user_id String
  user    User   @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@id([role_id, user_id])
  @@map("role_users")
}

// this table stores notification event
model NotificationEvent {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  status Int?    @default(1) @db.SmallInt
  type   String?
  text   String?

  notifications Notification[]

  @@map("notification_events")
}

model Notification {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  read_at DateTime?

  status Int? @default(1) @db.SmallInt

  sender_id String?
  sender    User?   @relation("sender", fields: [sender_id], references: [id])

  receiver_id String?
  receiver    User?   @relation("receiver", fields: [receiver_id], references: [id])

  notification_event_id String?
  notification_event    NotificationEvent? @relation(fields: [notification_event_id], references: [id])

  entity_id String?

  @@map("notifications")
}

model UserPaymentMethod {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  user_id String?
  user    User?   @relation(fields: [user_id], references: [id])

  payment_method_id String?
  checkout_id       String?
  // Added detailed card / wallet metadata for displaying in subscription screens
  brand             String? // e.g. visa, mastercard
  last4             String? // last 4 digits
  exp_month         Int?
  exp_year          Int?
  funding           String? // credit, debit, prepaid
  method_type       String? // card | wallet | bank
  is_default        Boolean? @default(false)

  // reverse relation: a payment method can have many subscriptions over time
  subscriptions Subscription[]

  @@map("user_payment_methods")
}

model PaymentTransaction {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  store_id String?

  user_id String?
  user    User?   @relation(fields: [user_id], references: [id])

  order_id         String?
  type             String?  @default("order")
  withdraw_via     String?  @default("wallet")
  provider         String?
  reference_number String?
  status           String?  @default("pending")
  raw_status       String?
  amount           Decimal?
  currency         String?
  paid_amount      Decimal?
  paid_currency    String?

  @@map("payment_transactions")
}

// Subscription model

model Subscription {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  user_id String?
  user    User?   @relation(fields: [user_id], references: [id])

  plan_name   String?
  description String?
  plan_id     String?
  price       Decimal?
  currency    String?
  interval    String? // e.g. month, year

  status                 String?            @default("active")
  start_date             DateTime?
  end_date               DateTime?
  cancel_at_end          Boolean?           @default(false)
  canceled_at            DateTime?
  trial_start            DateTime?
  trial_end              DateTime?
  subscription_id        String? // e.g. stripe subscription id
  next_billing_date      DateTime? // mirrors Stripe current_period_end for display
  // Linked payment method snapshot (denormalized for historical accuracy)
  payment_method_id      String? // stripe payment_method id
  payment_method_brand   String?
  payment_method_last4   String?
  payment_method_funding String?
  payment_method_type    String? // card | wallet
  user_payment_method_id String? // relation to stored payment method
  user_payment_method    UserPaymentMethod? @relation(fields: [user_payment_method_id], references: [id])

  @@unique([subscription_id])
  @@map("subscriptions")
}

model Habit {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  status      Int?           @default(1) @db.SmallInt
  habit_name  String?
  description String?
  category    HabitCategory?

  frequency Frequency?

  preferred_time PreferredTime?
  reminder_time  String?
  duration       Int? // in minutes

  user_id String?
  user    User?   @relation(fields: [user_id], references: [id], onDelete: Cascade)

    statistics Statistics[] @relation("HabitStatistics")
    Reminders  Reminders[]
    logs       HabitLog[]

  @@map("habits")
}

enum HabitCategory {
  Meditation
  SoundHealing @map("Sound healing")
  Journaling
  Podcast
}

enum Frequency {
  Daily
  Weekly
  Weekdays
  Weekends
}

enum PreferredTime {
  Morning   @map("Morning (6-10am)")
  Afternoon @map("Afternoon (10am-2pm)")
  Evening   @map("Evening (2pm-6pm)")
  Night     @map("Night (6pm-10pm)")
}

model Reminders {
  id         String   @id @default(cuid())
  created_at DateTime @default(now())
  updated_at DateTime @default(now())

  user_id String?
  user    User?   @relation(fields: [user_id], references: [id])

  habit_id String?
  habit    Habit?  @relation(fields: [habit_id], references: [id])

  routine_id  String?
  routine     Routine? @relation(fields: [routine_id], references: [id], onDelete: Cascade)

  name   String?
  time   String?
  days   String? // e.g. "Mon,Tue,Wed"
  active Boolean? @default(true)

  scheduled_at DateTime?
  window String?
  tz String?
  last_triggered_at DateTime?

  @@map("reminders")
}

// Logs each time a user completes a habit (one per habit per day by default)
model HabitLog {
  id            String   @id @default(cuid())
  created_at    DateTime @default(now())
  updated_at    DateTime @default(now())
  user_id       String
  habit_id      String
  day           DateTime // UTC day bucket (startOfDay UTC)
  completed_at  DateTime @default(now())
  duration_minutes Int?
  note          String?  @db.VarChar(500)

  user  User  @relation(fields: [user_id], references: [id], onDelete: Cascade)
  habit Habit @relation(fields: [habit_id], references: [id], onDelete: Cascade)
  // (Removed direct Reminders relation for simplicity; can be reinstated if needed.)

  @@unique([habit_id, day])
  @@index([user_id, day])
  @@index([habit_id, day])
  @@map("habit_logs")
}

model Mood {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())

  status Int?    @default(1) @db.SmallInt
  mood   String?
  note   String?

  rate_overall_mood   Int?      @default(0)
  emotion             Emotions?
  Additional_thoughts String?

  user_id String?
  user    User?   @relation(fields: [user_id], references: [id], onDelete: Cascade)

  statistics_id String?
  statistics    Statistics? @relation("MoodStatistics", fields: [statistics_id], references: [id])

  @@map("moods")
}

enum Emotions {
  Peaceful
  Grateful
  Energetic
  Focused
  Calm
  Hopeful
  Anxious
  Tired
  Stressed
  OverWhelmed
  Sad
  Frustrated
  Excited
  Creative
  Motivated
  Relexed
  Inspired
  Content
  Happy
  Angry
  Lonely
}

model Statistics {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  user_id String?
  user    User?   @relation(fields: [user_id], references: [id])

  date       DateTime?
  habits     Habit[]   @relation("HabitStatistics")
  moods      Mood[]    @relation("MoodStatistics")
  mood_count Int?      @default(0)

  current_streak   Int?   @default(0)
  completion_rate  Float? @default(0.0)
  total_time_spent Int?   @default(0) // in minutes
  average_mood     Float? @default(0.0)

  achievements Json[] @default([])

  @@map("statistics")
}

model Inspiration {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  status Int?    @default(1) @db.SmallInt
  quote  String?
  author String?

  user_id String?
  user    User?   @relation(fields: [user_id], references: [id])

  keyword InspirationKeyword?

  @@map("inspirations")
}

// ================= Mood Tracking (new implementation) =================

model MoodEntry {
  id              String    @id @default(cuid())
  created_at      DateTime  @default(now())
  updated_at      DateTime  @default(now())
  deleted_at      DateTime?

  user_id String
  user    User     @relation(fields: [user_id], references: [id], onDelete: Cascade)

  score   Int      // 1-10 overall mood rating
  emotions String[] 
  note    String?   @db.VarChar(1000)

  // AI enrichment (optional)
  ai_summary     String?   @db.VarChar(300)
  ai_suggestions String?   
  ai_model       String?
  ai_tokens_in   Int?
  ai_tokens_out  Int?
  ai_error       String?

  sentiment_score Float?    
  energy_score    Float?

  @@index([user_id, created_at])
  @@map("mood_entries")
}

model MoodDailyAggregate {
  id            String    @id @default(cuid())
  created_at    DateTime  @default(now())
  updated_at    DateTime  @default(now())
  user_id String
  user    User     @relation(fields: [user_id], references: [id], onDelete: Cascade)

  date        DateTime    // UTC midnight representing user's local date bucket
  count_entries Int       @default(0)
  avg_score     Float     @default(0)
  min_score     Int       @default(0)
  max_score     Int       @default(0)
  emotions_top  String[]
  last_entry_id String?

  @@unique([user_id, date])
  @@index([user_id, date])
  @@map("mood_daily_aggregates")
}

enum InspirationKeyword {
  Peace
  Love
  Mindfulness
  Gratitude
}

// ---------Start Chat schema---------

enum MessageStatus {
  PENDING
  SENT
  DELIVERED
  READ
}

// message is used for conversation
model Message {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  status MessageStatus? @default(PENDING)

  sender_id String?
  sender    User?   @relation("sender", fields: [sender_id], references: [id])

  receiver_id String?
  receiver    User?   @relation("receiver", fields: [receiver_id], references: [id])

  conversation_id String?
  conversation    Conversation? @relation(fields: [conversation_id], references: [id], onDelete: Cascade)

  attachment_id String?
  attachment    Attachment? @relation(fields: [attachment_id], references: [id])

  message String?

  @@map("messages")
}

// this table stores attachment of message
model Attachment {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  name     String?
  type     String?
  size     Int?
  file     String?
  file_alt String?

  messages Message[]

  @@map("attachments")
}

// this table stores conversation
model Conversation {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  creator_id String?
  creator    User?   @relation("creator", fields: [creator_id], references: [id])

  participant_id String?
  participant    User?   @relation("participant", fields: [participant_id], references: [id])

  messages Message[]

  @@map("conversations")
}

// ---------End Chat schema---------

model Faq {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  status     Int?    @default(1) @db.SmallInt
  sort_order Int?    @default(0)
  question   String?
  answer     String?

  @@map("faqs")
}

model Contact {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  first_name   String?
  last_name    String?
  email        String?
  phone_number String?
  message      String?

  @@map("contacts")
}

// Support tickets submitted by users (in-app contact support)
model SupportTicket {
  id          String   @id @default(cuid())
  created_at  DateTime @default(now())
  updated_at  DateTime @default(now())
  user_id     String?
  user        User?    @relation(fields: [user_id], references: [id], onDelete: SetNull)
  email       String?
  description String
  status      SupportTicketStatus @default(OPEN)
  resolved_at DateTime?

  @@index([user_id])
  @@map("support_tickets")
}

enum SupportTicketStatus {
  OPEN
  CLOSED
  RESOLVED
}

model Setting {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  category      String?
  label         String?
  description   String?
  key           String? @unique
  default_value String?

  user_settings UserSetting[]

  @@map("settings")
}

model WebsiteInfo {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  name                String?
  phone_number        String?
  email               String?
  address             String?
  logo                String?
  favicon             String?
  copyright           String?
  cancellation_policy String?

  @@map("website_infos")
}

model UserSetting {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  user_id String?
  user    User?   @relation(fields: [user_id], references: [id])

  setting_id String?
  setting    Setting? @relation(fields: [setting_id], references: [id])

  value String?

  @@map("user_settings")
}

// ================= AI Routines =================

enum RoutineStatus {
  generated
  started
  completed
}

enum RoutineItemType {
  Meditation
  SoundHealing @map("Sound healing")
  Journaling
  Podcast
}

enum RoutineItemStatus {
  pending
  completed
}

model UserRoutineProfile {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())

  user_id String @unique
  user    User   @relation(fields: [user_id], references: [id], onDelete: Cascade)

  onboarding_completed_at DateTime?
  preferences Json? // arbitrary user choices (duration, preferred types, times)
  onboarding_version Int? @default(1)

  @@map("user_routine_profiles")
}

model Routine {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())

  user_id String
  user    User   @relation(fields: [user_id], references: [id], onDelete: Cascade)

  date       DateTime // calendar day for which this routine applies (UTC day bucket)
  status     RoutineStatus @default(generated)
  mood_entry_id String?
  mood_check_id String?
  mood_check    RoutineMoodCheck? @relation(fields: [mood_check_id], references: [id], onDelete: SetNull)
  remind_at  DateTime?
  completed_at DateTime?
  notes      String?
  profile_snapshot Json? // snapshot of preferences used for generation

  items RoutineItem[]
  Reminders Reminders[]

  @@unique([user_id, date])
  @@index([user_id, date])
  @@map("routines")
}

model RoutineItem {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())

  routine_id String
  routine    Routine @relation(fields: [routine_id], references: [id], onDelete: Cascade)

  type       RoutineItemType
  title      String?
  description String?
  gcs_path   String?    // path in Firebase Storage bucket
  content_type String?   // audio | text | video
  duration_min Int?
  order      Int? @default(0)

  status     RoutineItemStatus @default(pending)
  completed_at DateTime?
  journal_text String?

  @@index([routine_id])
  @@map("routine_items")
}

model RoutineMoodCheck {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())

  user_id String
  user    User   @relation(fields: [user_id], references: [id], onDelete: Cascade)
  routine Routine[]

  rating    Int?
  emotions  String[]
  statements String[]
  note      String?   @db.VarChar(1000)

  @@index([user_id, created_at])
  @@map("routine_mood_checks")
}
